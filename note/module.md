[👈](./index.md)

## 模块系统

[TOC]

### 模块对象

Node.js 提供了模块化编程的能力。每个单独的文件可以被看做是独立的模块。每个模块拥有独立的作用域，模块之间无法直接访问成员变量。只能通过导出和引用的方式进行模块间的通信。在每一个模块内部都定义了一个 module 对象，模块的导出就是通过这个对象的 exports 属性来实现的。

### 模块引用

模块提供了一个 require 方法，用来引用外部模块。

```javascript
const fs = require('fs')
const a = require('./a.js')
```

调用 require 方法，其实就是执行了模块中的代码，所以外部模块中的顶层代码会先于 require 之后的语句执行 ，同时返回模块的 exports 属性。但是只有在模块文件第一次被引用时才会被执行。执行过程如下：

1. 解析文件路径；
   1. 如果是核心模块，直接返回核心模块名称；
   2. 如果是绝对路径或者相对路径，直接查找对应文件或文件夹；
      1. 如果不是文件夹，尝试查找对应文件，如果文件不存在，尝试查找是否是以 `.js` `.json` `.node` `.mjs` 结尾的文件，如果找不到就报错；
      2. 如果是文件夹，尝试找到 package.json 下的 main 属性，查找对应的文件或者对应文件夹下的 index 文件，如果找不到 main 属性或者 main 属性对应的文件找不到，则返回当前文件夹下的 index 文件，如果找不到就报错；
   3. 否则，遍历每一层父级文件夹中的 node_modules 和全局 node_modules 目录，按照第二种方式进行查找，直到找到对应文件。
2. 判断缓存中是否存在；
3. 如果有缓存，则返回 exports；
4. 如果没有缓存，尝试从核心模块中查找；
5. 如果是核心模块则返回 exports；
6. 如果不是，创建 module 对象，缓存对象，然后加载并执行模块，返回 exports 。



### 模块导出

Node.js 中没有全局作用域，只有模块作用域，内部的变量只会在当前为文件模块中访问。模块中有一个预定义的对象 exports ，只有挂载在 exports 上的变量才可以被外部模块访问。实际上 require 的返回值就是对应模块对象中的 exports 。

```javascript
// 变量 bar，不可以直接在外部文件中访问，只有挂载到 exports 上，才可以被访问。 
const bar = 'bar'
exports.bar = bar
exports.foo = function () 
```



### 模块类型

Node.js 中一共有三种模块，核心模块，自定义文件模块和第三方模块。但是本质上都是一个 js 文件。

#### 核心模块

Node.js 中有以下几种常见的核心模块：

- fs：文件的读写等操作；
- http：搭建服务器相关 API；
- path：对文件路径操作的 API；
- os：系统相关信息的 API；
- url：操作 URL 信息的API



#### 自定义模块

事实上，一个单独的 js 文件就可以看作一个单独的模块。在需要导入的文件中通过 `require('./a.js')`引用。

对于引用自定义模块需要注意的是，路径中的文件后缀 `.js` 可以省略，但是 `./` 不能省略。

```javascript
// 错误
require('a')
require('a.js')

// 正确
require('./a')
require('./a.js')
```



#### 第三方模块

第三方模块就是通过 npm 安装在 node_modules 文件夹中的第三方依赖，直接通过 require 引用，路径中不需要包含 node_modules 文件夹，直接以第三方包名开头，定位到需要的文件。

