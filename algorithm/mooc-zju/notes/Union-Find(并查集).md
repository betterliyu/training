### 定义

并查集是一种数据结构，可以理解成是多个不相交集合的组合。不同集合之间不会出现交集。用于处理这些集合的合并和查找操作。

合并：将两个集合合并为一个集合；

查找：查找指定元素属于哪个集合。一般利用树的结构特点，返回集合的根节点。主要用来判断两个元素是否属于同一个集合。

![image-20210203154134202](Union-Find(%E5%B9%B6%E6%9F%A5%E9%9B%86).assets/image-20210203154134202.png)



### 代码实现

使用一个结构数组来存储元素，每个数组元素包含一个指向其父结点的指针。通过查询根结点，来判断两个元素是否在同一颗树上。将上面的树状结构表示成数组结构，根结点的父节点用 -1 表示。

![image-20210203154150722](Union-Find(%E5%B9%B6%E6%9F%A5%E9%9B%86).assets/image-20210203154150722.png)

#### 查找

```javascript
function find(list, item) {
  let x = item;
  while (list[x] >= 0) {
    x = list[x]
  }
  return x;
}
```

#### 合并

```javascript
function union(list, a, b) {
  const aParent = find(list, a);
  const bParent = find(list, b);
  if (aParent != bParent) {
    list[bParent] = aParent;
  }
}
```



### 问题与优化

在合并的时候，我们直接将一个结点直接加在另外一个结点上面，但是这样会造成树的深度很大，不利于查找。知道了缺点，我们需要调整一下合并的方式，从来减少查询的消耗。

1. 我们可以考虑将小的树加到大的树下面。利用一个额外的变量保存树的高度，将小树加到大树下面，如果树一样高，那么合并后的树高度就会加一。

2. 更极端的，我们可以采用压缩路径的方式，将所有结点尽可能的靠近根结点，这样时间复杂度直接变成$O(1)$。代码实现也很简单，我们只需要在查找的时候将结点一步一步地挪到父结点那一层，下面图示：

   有这样的一棵树[1, 2, 3, 4, 5, 6, 7]：

   第一次查找 7 的根元素，我们需要一级一级的往上找。如果我们父结点 6 不是根节点，我们们就在回溯到父结点 6 之前把根结点指向爷爷结点 5，然后从 5 开始向上溯源；再重复判断结点 5 是不是根结点，发现不是，那我们就把结点 5 指向 结点 3。直到找到根结点。 

   ![image-20210203164918899](Union-Find(%E5%B9%B6%E6%9F%A5%E9%9B%86).assets/image-20210203164918899.png)

   这时候我们发现 结点 3，4，5，6，7 都离根结点更近了，如果我们又进行了两次查找 7 ，那么我们会发现 7 已经直接指向根结点了。

   ![image-20210203165210481](Union-Find(%E5%B9%B6%E6%9F%A5%E9%9B%86).assets/image-20210203165210481.png)

   可以发现，数次查找之后，所有结点都会指向根结点。

   但是需要注意的是，如果两个数合并之后，树的总高度是要加1的，即便如此，树的高度永远也不会超过3.

    ![image-20210203165836557](Union-Find(%E5%B9%B6%E6%9F%A5%E9%9B%86).assets/image-20210203165836557.png)

   代码如下：

   ```javascript
   function find_compress(list, item) {
     let x = item;
     while (list[x] >= 0) {
       if(list[list[x]] != -1) {  // 如果父结点不是指向 -1，即存在爷爷结点
         list[x] = list[list[x]]
       }
       x = list[x]
     }
     return x;
   }
   ```

   

