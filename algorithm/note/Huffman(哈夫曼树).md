### 定义

**带权路径长度(WPL)**：设二叉树有 n 个叶子结点，每个叶子结点带有权值 w~k~ ，从根结点到叶子结点的长度为 l~k~，则每个叶子结点的带权路径长度之和就是：$WPL= \sum^n_{k=1}w_kl_k$。

**哈夫曼树**也叫最优二叉树：**WPL** 值最小的树。



### 特点

1. 没有度为 1 的结点，意思是没有子结点个数为 1 的结点；

2. n 个叶子结点的哈夫曼树共有 2n - 1 个结点；

   对于任意二叉树：
   $$
   n_2 = n_0 - 1     
   (n_0 = 叶结点总数，n_1 = 有一个子结点的节点数，n_2 = 有两个子结点的节点数)
   $$
   哈夫曼树没有度为 1 的结点，所以 $n_总 = n_0 + n_2 = n_0 + n_0 - 1 = 2n_0-1$

   

3. 任意非叶结点的左右子树交换后还是哈夫曼树；

4. 对同一组权值，==存在不同构==的两颗哈夫曼树。 

   比如 $[1, 2, 3, 3]$ 第一次合并后为 $[3,3,3]$，这时就存在两种合并方式。

### 创建

给定一个带有权值的元素序列，所有元素充当叶子结点可以创建出多种二叉树，但是我们需要一个 *WPL* 值最小的二叉树。

我们可以每次把权值最小的两颗二叉树合并，这样组合的二叉树拥有最小的 *WPL* 值。

**代码实现思路**：

每次从序列中拿出两个最小的值，组合之后重新添加到序列中，直到操作 n 次后，所有的值都被合并成功。我们可以利用堆的特性来实现删除最小值和插入新值的操作。

时间复杂度：$O(nlogn)$

```javascript
function createHuffmanTree(list) {
  // 根据权值创建最小堆
  let heap = createMinHeap(list);
  // 两两最小的值相加，需要操作 size 次，size 次操作后会得到一个所有值合并后的结点
  let times = heap.size;
  for (let index = 1; index < times; index++) {
    const huffman = new HuffmanTree();
    // 取出两个最小值合并
    huffman.left = deleteMin(heap);
    huffman.right = deleteMin(heap);
    huffman.weight = huffman.left.weight + huffman.right.weight;
    // 将合并后的值插入到最小堆中
    insert(heap, huffman);
  }
  // 返回最小堆的第一个结点
  return deleteMin(heap);
}
```



### 应用

#### 哈夫曼编码

一种==可变字长==编码方式。

有一个哈夫曼树，我们将左结点的路径表示为 0 ，右结点路径表示为 1 。有下面一棵树， 

![image-20210127120503259](Huffman(%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91).assets/image-20210127120503259.png)

可以表示成：

a：0

x：10

u：110

z：111

把字母出现的频率看出树结点的权值，把权值高的放在靠近根结点的位置，权值低的放在原理根结点的位置，这样我们就可以用最小的空间来表示一连串重复出现的字符。

而且每个结点都是叶结点，不会出现在其他叶结点的路径上，所以也不会出现一个符号的编码是另一个编码的前缀这样的混淆。

